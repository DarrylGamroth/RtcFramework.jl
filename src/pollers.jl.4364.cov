        - """
        - Type-stable function wrapper for poller functions.
        - Signature: (agent::AbstractRtcAgent) -> Int (work count)
        - """
        - const PollerFunction = FunctionWrapper{Int,Tuple{AbstractRtcAgent}}
        - 
        - """
        -     PollerConfig
        - 
        - Configuration for a registered poller including its function, priority, and name.
        - 
        - # Fields
        - - `poll_fn::PollerFunction`: Type-stable polling function
        - - `priority::Int`: Priority level (lower = higher priority)
        - - `name::Symbol`: Identifier for debugging and management
        - """
        - struct PollerConfig
      134     poll_fn::PollerFunction
        -     priority::Int
        -     name::Symbol
        - end
        - 
        - """
        -     PollerRegistry
        - 
        - Internal structure for managing pollers with deferred add/remove operations.
        - Pollers can safely request add/remove during iteration without breaking the loop.
        - 
        - # Fields
        - - `pollers::Vector{PollerConfig}`: Current active pollers (sorted by priority)
        - - `add::Vector{PollerConfig}`: Buffer for pollers to add after iteration
        - - `remove::Vector{Symbol}`: Names queued for removal after iteration
        - """
        - struct PollerRegistry
       36     pollers::Vector{PollerConfig}
        -     add::Vector{PollerConfig}
        -     remove::Vector{Symbol}
        - end
        - 
        - function PollerRegistry()
       36     pollers = Vector{PollerConfig}()
       36     add = Vector{PollerConfig}()
       36     remove = Vector{Symbol}()
        -     @static if VERSION >= v"1.11"
       36         sizehint!(pollers, 10; shrink=false)
       36         sizehint!(add, 10; shrink=false)
       36         sizehint!(remove, 10; shrink=false)
        -     else
        -         sizehint!(pollers, 10)
        -         sizehint!(add, 10)
        -         sizehint!(remove, 10)
        -     end
       36     return PollerRegistry(pollers, add, remove)
        - end
        - 
        - # =============================================================================
        - # Collections Interface for PollerRegistry
        - # =============================================================================
        - 
        - """
        - Implement the collections interface for PollerRegistry.
        - Allows iteration, length queries, and indexed access to active pollers.
        - """
        - 
        - # Iteration interface - iterate over active pollers only
        6 Base.iterate(registry::PollerRegistry) = iterate(registry.pollers)
       19 Base.iterate(registry::PollerRegistry, state) = iterate(registry.pollers, state)
        - 
        - # Length and size
       13 Base.length(registry::PollerRegistry) = length(registry.pollers)
        - Base.size(registry::PollerRegistry) = (length(registry.pollers),)
        - 
        - # Element type
        - Base.eltype(::Type{PollerRegistry}) = PollerConfig
        - 
        - # Indexed access - read-only access to active pollers
        1 Base.getindex(registry::PollerRegistry, i::Int) = registry.pollers[i]
        - 
        - # Keys for dictionary-like access (1-based indexing)
        1 Base.keys(registry::PollerRegistry) = keys(registry.pollers)
        - Base.firstindex(registry::PollerRegistry) = 1
        - Base.lastindex(registry::PollerRegistry) = length(registry.pollers)
        - 
        - # Check if empty
        3 Base.isempty(registry::PollerRegistry) = isempty(registry.pollers)
        - 
        - # Empty the collection
       10 function Base.empty!(registry::PollerRegistry)
       10     empty!(registry.add)
       10     empty!(registry.remove)
       10     empty!(registry.pollers)
        - end
        - 
        - # Membership test - check if poller name exists
       28 Base.in(name::Symbol, registry::PollerRegistry) = any(c -> c.name === name, registry.pollers)
        - 
        - # Built-in poller priorities (internal constants, not exported)
        - const PRIORITY_INPUT = 10              # Input stream polling
        - const PRIORITY_PROPERTY = 50           # Property publishing
        - const PRIORITY_TIMER = 75              # Timer events
        - const PRIORITY_CONTROL = 200           # Control messages
        - 
        - # =============================================================================
        - # Internal PollerRegistry Operations
        - # =============================================================================
        - 
        - """
        -     add!(registry::PollerRegistry, config::PollerConfig)
        - 
        - Request to add a poller after the current poll iteration completes.
        - Safe to call from within a poller function.
        - 
        - Throws `ArgumentError` if a poller with the same name is already registered or
        - queued for addition. Names slated for removal are allowed (supports unregister
        - then register in the same cycle).
        - """
      134 function add!(registry::PollerRegistry, config::PollerConfig)
        -     # Check for duplicates in pending additions
      134     for c in registry.add
      205         if c.name === config.name
        0             throw(ArgumentError("Poller name $(config.name) already registered"))
        -         end
      205     end
        - 
        -     # Allow re-registration if name is queued for removal
      134     if config.name in registry.remove
        1         push!(registry.add, config)
        1         return
        -     end
        - 
        -     # Check for duplicates in active pollers
      133     for c in registry.pollers
       65         if c.name === config.name
        0             throw(ArgumentError("Poller name $(config.name) already registered"))
        -         end
       65     end
        - 
      133     push!(registry.add, config)
        - end
        - 
        - """
        -     remove!(registry::PollerRegistry, name::Symbol)
        - 
        - Request to remove a poller after the current poll iteration completes.
        - Safe to call from within a poller function.
        - """
        3 function remove!(registry::PollerRegistry, name::Symbol)
        -     # Cancel pending additions with the same name before queueing removal.
        3     for (i, config) in Iterators.reverse(pairs(registry.add))
        0         if config.name === name
        0             deleteat!(registry.add, i)
        0             return
        -         end
        0     end
        - 
        3     if name in registry.remove
        0         return
        -     end
        - 
        3     push!(registry.remove, name)
        - end
        - 
        - """
        -     apply!(registry::PollerRegistry)
        - 
        - Apply pending add/remove operations to the poller list.
        - Called internally after each poll iteration.
        - 
        - # Algorithm
        - 1. Remove pollers with names queued in remove (order-preserving filter)
        - 2. Insert queued pollers into the sorted list using binary search
        - 3. Clear buffers
        - """
101920861 function apply!(registry::PollerRegistry)
101920861     pollers = registry.pollers
        - 
        -     # Remove requested pollers (order-preserving)
101920861     remove = registry.remove
101920861     if !isempty(remove)
        3         filter!(pollers) do config
       25             !(config.name in remove)
        -         end
        3         empty!(remove)
        -     end
        - 
        -     # Add new pollers
101920861     add = registry.add
101920861     if !isempty(add)
       22         for config in add
        -             # Preserve FIFO order for identical priorities by inserting after
        -             # the last poller with the same priority.
      127             priorities = [c.priority for c in pollers]
       70             insert_at = searchsortedlast(priorities, config.priority)
       70             insert!(pollers, insert_at + 1, config)
       70         end
       22         empty!(add)
        -     end
        - end
        - 
        - """
        -     poll(registry::PollerRegistry, agent::AbstractRtcAgent) -> Int
        - 
        - Execute a single poll cycle across the current poller set and apply any queued
        - add/remove operations afterwards.
        - """
        - @inline function poll(registry::PollerRegistry, agent::AbstractRtcAgent)
101920861     pollers = registry.pollers
101920861     work_count = 0
        - 
101920861     for p in pollers
407683431         work_count += p.poll_fn(agent)
407683431     end
        - 
101920861     apply!(registry)
101920861     return work_count
        - end
        - 
        - # =============================================================================
        - # Public API
        - # =============================================================================
        - 
        - """
        -     register!(poll_fn, registry::PollerRegistry, name::Symbol, priority::Int)
        - 
        - Register a poller function with a PollerRegistry at the specified priority level.
        - Lower priority values are polled first (0 = highest priority).
        - 
        - Pollers with the same priority execute in registration order (FIFO) and each
        - poller name must be unique. Attempting to register a duplicate name throws an
        - `ArgumentError`.
        - 
        - **Note**: Registration is deferred and applied after the current poll cycle completes.
        - This makes it safe to register pollers from within other pollers.
        - 
        - # Arguments
        - - `poll_fn`: Function with signature `(agent::AbstractRtcAgent) -> Int`
        - - `registry`: The PollerRegistry to register with
        - - `name`: Required identifier for the poller
        - - `priority`: Priority level as Int (built-in pollers use 10, 50, 75, 200)
        - 
        - # Examples
        - ```julia
        - # Register a custom poller with high priority (between input=10 and property=50)
        - register!(my_custom_poll_fn, pollers(agent), :custom_sensor, 25)
        - 
        - # Register with inline function at normal priority
        - register!(pollers(agent), :my_poller, 100) do agent
        -     # Poll logic here
        -     return work_count
        - end
        - 
        - # Register multiple pollers at same priority (execute in registration order)
        - register!(poll_a, pollers(agent), :poller_a, 100)  # Runs first
        - register!(poll_b, pollers(agent), :poller_b, 100)  # Runs second
        - ```
        - """
        - function register!(poll_fn, registry::PollerRegistry, name::Symbol, priority::Int)
        -     # Wrap function for type stability
      134     wrapped_fn = PollerFunction(poll_fn)
      134     config = PollerConfig(wrapped_fn, priority, name)
        - 
        -     # Defer the add operation
      134     add!(registry, config)
        - end
        - 
        - """
        -     unregister!(registry::PollerRegistry, name::Symbol)
        - 
        - Unregister a poller by name from a PollerRegistry.
        - 
        - **Note**: Removal is deferred and applied after the current poll cycle completes.
        - This makes it safe to unregister pollers from within other pollers.
        - 
        - If the poller is not found, this function does nothing (idempotent).
        - 
        - # Examples
        - ```julia
        - unregister!(pollers(agent), :my_custom_poller)
        - ```
        - """
        4 function unregister!(registry::PollerRegistry, name::Symbol)
        -     # Cancel any pending addition first
        4     for (i, config) in Iterators.reverse(pairs(registry.add))
        0         if config.name === name
        0             deleteat!(registry.add, i)
        0             return
        -         end
        0     end
        - 
       36     if findfirst(c -> c.name === name, registry.pollers) !== nothing
        3         remove!(registry, name)
        -     end
        - end
