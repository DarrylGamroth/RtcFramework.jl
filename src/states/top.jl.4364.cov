        - # Top state handlers
        - # Handles top-level events like heartbeat, reset, errors, and system commands
        - 
        - @statedef AbstractRtcAgent :Top
        - 
       28 @on_initial function (sm::AbstractRtcAgent, ::Top)
       28     Hsm.transition!(sm, :Ready)
        - end
        - 
       28 @on_entry function (sm::AbstractRtcAgent, ::Top)
       28     b = base(sm)
        - 
        -     # Create control stream adapter
       28     b.control_adapter = ControlStreamAdapter(
        -         b.comms.control_stream,
        -         sm
        -     )
        - 
        -     # Create input stream adapters
       28     for input_stream in b.comms.input_streams
        0         push!(b.input_adapters, InputStreamAdapter(input_stream, sm))
        0     end
        - 
        -     # Create proxy instances
       28     b.status_proxy = StatusProxy(b.comms.status_stream)
       28     b.property_proxy = PropertyProxy(b.comms.output_streams)
        - 
        -     # Register pollers
        - 
        -     # Set up pollers - register built-in pollers
       28     register!(input_poller, pollers(sm), :input_streams, PRIORITY_INPUT)
        - 
        -     # Property publishing poller
       28     register!(property_poller, pollers(sm), :properties, PRIORITY_PROPERTY)
        - 
        -     # Timer poller
       28     register!(timer_poller, pollers(sm), :timers, PRIORITY_TIMER)
        - 
        -     # Control message poller (lowest priority)
       28     register!(control_poller, pollers(sm), :control_stream, PRIORITY_CONTROL)
        - 
        -     # Schedule recurring timers
       28     schedule!(b.timers, 0, :Heartbeat)
       28     schedule!(b.timers, 0, :GCStats)
       28     schedule!(b.timers, 0, :StatsUpdate)
        - end
        - 
        9 @on_exit function (sm::AbstractRtcAgent, ::Top)
        9     b = base(sm)
        - 
        -     # Cancel all scheduled timers
        9     cancel!(b.timers)
        - 
        -     # Clear all pollers
        9     empty!(pollers(sm))
        - 
        -     # Clear the input adapters
        9     empty!(b.input_adapters)
        - 
        -     # Empty the publication configs
        9     empty!(b.publication_configs)
        - 
        -     # Clear adapters and proxies
        9     b.property_proxy = nothing
        9     b.status_proxy = nothing
        9     b.control_adapter = nothing
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, state::Top, ::Reset, _)
        0     Hsm.transition!(sm, state)
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, event::Heartbeat, now::Int64)
      232     publish_event_response(sm, event, Hsm.current(sm))
        - 
        -     # Reschedule the next heartbeat
      116     b = base(sm)
      232     next_heartbeat_time = now + b.properties[:HeartbeatPeriodNs]
      116     schedule_at!(b.timers, next_heartbeat_time, :Heartbeat)
        - 
      116     return Hsm.EventHandled
        - end
        - 
      113 @on_event function (sm::AbstractRtcAgent, ::Top, ::GCStats, now::Int64)
      113     b = base(sm)
      113     gc_stats = RtcFramework.GCStats(Base.gc_num())
        - 
        -     # Use StaticKV.value! to bypass READABLE access control (internal API)
      113     for fname in fieldnames(RtcFramework.GCStats)
     3277         prop_value = getfield(gc_stats, fname)
     3390         StaticKV.value!(b.properties, prop_value, fname)
     3390     end
        - 
        -     # Reschedule the next GCStats event
      226     next_gc_time = now + b.properties[:GCStatsPeriodNs]
      113     schedule_at!(b.timers, next_gc_time, :GCStats)
        - 
      113     return Hsm.EventHandled
        - end
        - 
      116 @on_event function (sm::AbstractRtcAgent, ::Top, ::StatsUpdate, now::Int64)
      116     b = base(sm)
      116     counters = b.counters
      116     props = b.properties
        - 
        -     # Calculate elapsed time using cached clock (zero overhead)
      116     elapsed_ns = now - b.last_stats_time
      116     elapsed_s = elapsed_ns / 1_000_000_000.0
        - 
      116     msg_count = counters.properties_published[]
      116     work_count = counters.total_work_done[]
      116     msg_delta = msg_count - b.last_msg_count
      116     work_delta = work_count - b.last_work_count
        - 
        -     # Use StaticKV.value! to bypass READABLE access control (internal API)
      116     StaticKV.value!(props, msg_delta / elapsed_s, :MessageRateHz)
      116     StaticKV.value!(props, work_delta / elapsed_s, :WorkRateHz)
      116     StaticKV.value!(props, counters.total_duty_cycles[], :TotalDutyCycles)
      116     StaticKV.value!(props, work_count, :TotalWorkDone)
      116     StaticKV.value!(props, msg_count, :PropertiesPublished)
      116     StaticKV.value!(props, counters.events_dispatched[], :EventsDispatched)
        - 
        -     # Save state for next delta calculation
      116     b.last_stats_time = now
      116     b.last_msg_count = msg_count
      116     b.last_work_count = work_count
        - 
        -     # Reschedule
      232     next_stats_time = now + props[:StatsPeriodNs]
      116     schedule_at!(b.timers, next_stats_time, :StatsUpdate)
        - 
      116     return Hsm.EventHandled
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, event::Error, (source_event, exception))
        0     publish_event_response(sm, event, exception)
        0     @error "Exception caught during event dispatch:" source_event exception = (exception, catch_backtrace())
        0     return Hsm.EventHandled
        - 
        -     # Transition to Error state
        -     # Hsm.transition!(sm, :Error)
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, ::AgentOnClose, _)
        0     Hsm.transition!(sm, :Exit)
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, event::State, _)
        0     publish_event_response(sm, event, Hsm.current(sm))
        0     return Hsm.EventHandled
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, ::Exit, _)
        9     Hsm.transition!(sm, :Exit)
        - end
        - 
        - @on_event function (sm::AbstractRtcAgent, ::Top, event::LateMessage, _)
        0     publish_event_response(sm, event, nothing)
        0     return Hsm.EventHandled
        - end
        - 
        0 @on_event function (sm::AbstractRtcAgent, ::Top, ::Properties, message)
        0     props = base(sm).properties
        0     for name in keynames(props)
        0         if is_readable(props, name)
        0             on_property_read(sm, name, message)
        -         end
        0     end
        0     return Hsm.EventHandled
        - end
