        - """
        - Test suite for unified poller system.
        - Tests poller registration, priority ordering, execution, and type stability.
        - """
        1 function test_pollers(client)
        1     @testset "Poller Registration" begin
        3         clock = CachedEpochClock(EpochClock())
        1         properties = TestAgent.Properties(clock)
        1         comms = CommunicationResources(client, properties)
        1         base_agent = BaseRtcAgent(comms, properties, clock)
        1         agent = TestAgent.RtcAgent(base_agent)
        - 
        -         # Start agent to register built-in pollers
        1         Agent.on_start(agent)
        - 
        -         @testset "Built-in pollers registered on start" begin
        -             # Apply deferred registrations from on_start
        3             Agent.do_work(agent)
        - 
        1             registry = pollers(agent)
        1             @test length(registry) == 4
        - 
        -             # Check that unconditional built-in pollers are registered
        1             @test :timers in registry
        1             @test :control_stream in registry
        - 
        -             # Verify priority order (lower number = higher priority)
        2             priorities = [p.priority for p in registry]
        3             @test issorted(priorities)
        -         end
        - 
        -         @testset "Custom poller registration" begin
        -             # Define a simple test poller
        3             test_poller_called = Ref(false)
        1             function test_poller(agent)
        5                 test_poller_called[] = true
        5                 return 1
        -             end
        - 
        -             # Register custom poller
        1             register!(test_poller, pollers(agent), :test_poller, 100)
        - 
        -             # Apply all registrations
        1             Agent.do_work(agent)
        - 
        -             # Verify it was added
        1             registry = pollers(agent)
        1             @test length(registry) == 5  # 4 built-in + 1 custom
        1             @test :test_poller in registry
        - 
        -             # Verify work is executed
        1             Agent.do_work(agent)
        2             @test test_poller_called[]
        -         end
        - 
        -         @testset "Multiple pollers at same priority (FIFO)" begin
        3             call_order = Int[]
        - 
        1             function poller_a(agent)
        3                 push!(call_order, 1)
        3                 return 0
        -             end
        - 
        1             function poller_b(agent)
        3                 push!(call_order, 2)
        3                 return 0
        -             end
        - 
        -             # Register both at same priority
        1             register!(poller_a, pollers(agent), :poller_a, 150)
        1             register!(poller_b, pollers(agent), :poller_b, 150)
        - 
        -             # Apply registrations
        1             Agent.do_work(agent)
        - 
        -             # Clear call order and execute again
        1             empty!(call_order)
        1             Agent.do_work(agent)
        - 
        -             # Verify FIFO order (poller_a registered first, should run first)
        1             @test length(call_order) >= 2
        2             idx_a = findfirst(==(1), call_order)
        3             idx_b = findfirst(==(2), call_order)
        1             @test idx_a < idx_b
        -         end
        - 
        -         @testset "Do-block syntax" begin
        3             do_block_called = Ref(false)
        - 
        1             register!(pollers(agent), :do_block_poller, 200) do agent
        1                 do_block_called[] = true
        1                 return 1
        -             end
        - 
        -             # Apply deferred registration
        1             Agent.do_work(agent)
        - 
        -             # Verify it was registered
        1             @test :do_block_poller in pollers(agent)
        - 
        -             # Verify it executes
        1             Agent.do_work(agent)
        2             @test do_block_called[]
        -         end
        - 
        1         Agent.on_close(agent)
        -     end
        - 
        -     @testset "Execution Order" begin
        3         clock = CachedEpochClock(EpochClock())
        1         properties = TestAgent.Properties(clock)
        1         comms = CommunicationResources(client, properties)
        1         base_agent = BaseRtcAgent(comms, properties, clock)
        1         agent = TestAgent.RtcAgent(base_agent)
        - 
        -         # Start with built-in pollers
        1         Agent.on_start(agent)
        - 
        -         @testset "Pollers execute in priority order" begin
        3             execution_order = Int[]
        - 
        -             # Register pollers with different priorities
        1             register!(pollers(agent), :highest, 5) do agent
        3                 push!(execution_order, 5)
        3                 return 0
        -             end
        - 
        1             register!(pollers(agent), :medium, 100) do agent
        3                 push!(execution_order, 100)
        3                 return 0
        -             end
        - 
        1             register!(pollers(agent), :high, 20) do agent
        3                 push!(execution_order, 20)
        3                 return 0
        -             end
        - 
        1             register!(pollers(agent), :lowest, 500) do agent
        3                 push!(execution_order, 500)
        3                 return 0
        -             end
        - 
        -             # Apply all registrations
        1             Agent.do_work(agent)
        - 
        -             # Execute all pollers
        1             empty!(execution_order)
        1             Agent.do_work(agent)
        - 
        -             # Verify priorities are in ascending order
        -             # (lower priority number executes first)
        3             @test issorted(execution_order)
        1             @test execution_order[1] == 5
        1             @test execution_order[end] == 500
        -         end
        - 
        -         @testset "Work count accumulation" begin
        -             # Register pollers that return specific work counts
        3             register!(pollers(agent), :work_5, 300) do agent
        1                 return 5
        -             end
        - 
        1             register!(pollers(agent), :work_3, 301) do agent
        1                 return 3
        -             end
        - 
        1             register!(pollers(agent), :work_7, 302) do agent
        1                 return 7
        -             end
        - 
        -             # Apply registrations first
        1             Agent.do_work(agent)
        - 
        -             # Execute and verify total work count includes custom pollers
        1             total_work = Agent.do_work(agent)
        1             @test total_work >= 15  # At least 5 + 3 + 7 from our custom pollers
        -         end
        - 
        1         Agent.on_close(agent)
        -     end
        - 
        -     @testset "Poller Management" begin
        3         clock = CachedEpochClock(EpochClock())
        1         properties = TestAgent.Properties(clock)
        1         comms = CommunicationResources(client, properties)
        1         base_agent = BaseRtcAgent(comms, properties, clock)
        1         agent = TestAgent.RtcAgent(base_agent)
        - 
        1         Agent.on_start(agent)
        - 
        -         @testset "Unregister poller by name" begin
        -             # Register a test poller
        3             register!(pollers(agent), :to_remove, 400) do agent
        1                 return 1
        -             end
        - 
        -             # Apply registration
        1             Agent.do_work(agent)
        - 
        1             initial_count = length(pollers(agent))
        - 
        -             # Unregister it (deferred)
        1             unregister!(pollers(agent), :to_remove)
        - 
        -             # Apply unregistration
        1             Agent.do_work(agent)
        1             @test length(pollers(agent)) == initial_count - 1
        - 
        -             # Verify it's gone
        1             @test !(:to_remove in pollers(agent))
        - 
        -             # Unregister non-existent poller (should be idempotent, no error)
        1             unregister!(pollers(agent), :nonexistent)
        -             # Should still work fine
        1             @test length(pollers(agent)) == initial_count - 1
        -         end
        - 
        -         @testset "Clear all pollers" begin
        -             # Register some custom pollers
        3             register!(pollers(agent), :custom1, 100) do agent; return 0; end
        1             register!(pollers(agent), :custom2, 200) do agent; return 0; end
        - 
        -             # Apply registrations
        1             Agent.do_work(agent)
        - 
        1             count_before = length(pollers(agent))
        1             @test count_before > 0
        - 
        -             # Clear all pollers (immediate)
        1             empty!(pollers(agent))
        1             @test length(pollers(agent)) == 0
        -         end
        - 
        -         @testset "List pollers" begin
        -             # Add a couple of test pollers to verify structure
        5             register!(pollers(agent), :list_test1, 100) do agent; return 0; end
        3             register!(pollers(agent), :list_test2, 200) do agent; return 0; end
        1             Agent.do_work(agent)
        - 
        1             registry = pollers(agent)
        - 
        -             # Verify structure of returned data
        1             @test registry isa RtcFramework.PollerRegistry
        1             @test length(registry) >= 2  # At least our 2 test pollers
        - 
        -             # Verify iteration
        1             for (idx, poller) in enumerate(registry)
        2                 @test poller isa RtcFramework.PollerConfig
        2                 @test poller.name isa Symbol
        2                 @test poller.priority isa Int
        3             end
        -         end
        - 
        -         @testset "Reordering pollers" begin
        -             # Register pollers with specific priorities
        4             register!(pollers(agent), :test_a, 50) do agent; return 0; end
        2             register!(pollers(agent), :test_b, 100) do agent; return 0; end
        1             Agent.do_work(agent)
        - 
        -             # Unregister and re-register with different priority
        1             unregister!(pollers(agent), :test_b)
        1             register!(pollers(agent), :test_b, 25) do agent; return 0; end
        - 
        -             # Apply changes
        1             Agent.do_work(agent)
        - 
        1             registry = pollers(agent)
        2             test_b = findfirst(p -> p.name == :test_b, registry)
        1             @test registry[test_b].priority == 25
        - 
        -             # Verify still in sorted order
        2             priorities = [p.priority for p in registry]
        3             @test issorted(priorities)
        -         end
        - 
        1         Agent.on_close(agent)
        -     end
        - 
        -     @testset "Type Stability" begin
        3         clock = CachedEpochClock(EpochClock())
        1         properties = TestAgent.Properties(clock)
        1         comms = CommunicationResources(client, properties)
        1         base_agent = BaseRtcAgent(comms, properties, clock)
        1         agent = TestAgent.RtcAgent(base_agent)
        - 
        1         Agent.on_start(agent)
        - 
        -         @testset "do_work is type-stable" begin
        -             # Register a custom poller
        3             register!(pollers(agent), :type_test, 100) do agent
        1                 return 42
        -             end
        - 
        -             # Apply registration and test that do_work returns Int
        1             Agent.do_work(agent)  # Apply registration
        1             result = @inferred Int Agent.do_work(agent)
        1             @test result isa Int
        -         end
        - 
        -         @testset "Poller functions are type-stable" begin
        -             # PollerFunction should wrap functions in type-stable way
        3             test_fn = agent -> 1
        1             wrapped = RtcFramework.PollerFunction(test_fn)
        - 
        1             @test wrapped isa RtcFramework.PollerFunction
        1             result = wrapped(agent)
        1             @test result isa Int
        -         end
        - 
        1         Agent.on_close(agent)
        -     end
        - 
        -     @testset "Built-in Pollers Integration" begin
        2         clock = CachedEpochClock(EpochClock())
        1         properties = TestAgent.Properties(clock)
        1         comms = CommunicationResources(client, properties)
        1         base_agent = BaseRtcAgent(comms, properties, clock)
        1         agent = TestAgent.RtcAgent(base_agent)
        - 
        -         @testset "Built-in pollers registered automatically" begin
        -             # Before on_start, no pollers
        3             @test isempty(pollers(agent))
        - 
        -             # After on_start, built-in pollers registered (but deferred)
        1             Agent.on_start(agent)
        - 
        -             # Apply deferred registrations
        1             Agent.do_work(agent)
        - 
        1             registry = pollers(agent)
        - 
        1             @test length(registry) == 4
        - 
        -             # Verify expected priorities for unconditional pollers
        1             poller_map = Dict(p.name => p.priority for p in registry)
        1             @test poller_map[:timers] < poller_map[:control_stream]
        -         end
        - 
        -         @testset "Built-in pollers cleared on exit" begin
        -             # Close via HSM from previous setup, then restart
        5             @test_throws AgentTerminationException dispatch!(agent, :Exit)
        1             Agent.on_close(agent)
        - 
        -             # Create a new agent AND new comms for restart test (can't reuse closed publications)
        1             comms2 = CommunicationResources(client, properties)
        1             agent = TestAgent.RtcAgent(BaseRtcAgent(comms2, properties, clock))
        1             Agent.on_start(agent)
        1             Agent.do_work(agent)  # Apply deferred registrations
        1             @test !isempty(pollers(agent))
        - 
        -             # Cleanup via HSM and then close external resources
        3             @test_throws AgentTerminationException dispatch!(agent, :Exit)
        1             @test isempty(pollers(agent))
        1             Agent.on_close(agent)
        -         end
        - 
        -         @testset "Custom pollers interleave with built-ins" begin
        -             # Create a new agent AND new comms since previous is in Exit state
        3             comms3 = CommunicationResources(client, properties)
        1             agent = TestAgent.RtcAgent(BaseRtcAgent(comms3, properties, clock))
        1             Agent.on_start(agent)
        1             Agent.do_work(agent)  # Apply built-in pollers
        - 
        -             # Add custom poller between timer and control
        1             register!(pollers(agent), :between_timer_control, 100) do agent
        -                 return 0
        -             end
        - 
        -             # Apply registration
        1             Agent.do_work(agent)
        - 
        1             registry = pollers(agent)
        1             positions = Dict(p.name => idx for (idx, p) in enumerate(registry))
        - 
        -             # Verify ordering (timers < custom < control)
        1             @test positions[:timers] < positions[:between_timer_control]
        1             @test positions[:between_timer_control] < positions[:control_stream]
        -         end
        - 
        1         Agent.on_close(agent)
        -     end
        - end
